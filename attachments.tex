\section{Приложения}
\subsection{Приложение 1}
\label{attach1}

\begin{lstlisting}[frame=single]
#ifndef OPTIMIZER_ALGORITHM_UNCONSTRAINED_HPP
#define OPTIMIZER_ALGORITHM_UNCONSTRAINED_HPP

#include "OptimizerCoreGlobal.hpp"
#include "OptimizerTask.hpp"
#include "OptimizerSolution.hpp"
#include "OptimizerFunction.hpp"
#include "OptimizerDataStructures.hpp"
#include "OptimizerSolution.hpp"
#include "OptimizerResult.hpp"
#include "OptimizerSearchSequence.hpp"

#include <set>

namespace optimizercore
{

	class EXPORT_API OptimizerAlgorithmUnconstrained final
	{

	private:

		bool mLocalMixType;
		bool mIsAlgorithmMemoryAllocated;
		bool mIsParamsInitialized;
		bool mIsTaskInitialized;
		bool mNeedLocalVerification;

		int mNumberOfThreads;
		int mLocalStartIterationNumber;
		int mMaxNumberOfIterations;
		int mMapTightness;
		int mMethodDimension;
		int mAlpha;
		int mLocalMixParameter;
		int mMapType;

		OptimizerSpaceTransformation mSpaceTransform;
		OptimizerFunction *mTargetFunction;
		OptimizerFunctionPtr mTargetFunctionSmartPtr;

		OptimizerInterval *mIntervalsForTrials;
		std::set<OptimizerTrialPoint> mSearchInformationStorage;
		OptimizerTrialPoint mOptimumEvaluation, *mNextTrialsPoints;

		LocalTuningMode mLocalTuningMode;

		double mGlobalM, mZ, eps, r, mMaxIntervalNorm;
		double **mNextPoints;

		void AllocMem();
		void InitializeInformationStorage();
		void UpdateGlobalM(std::set<OptimizerTrialPoint>::iterator&);
		int UpdateRanks(bool isLocal);
		bool InsertNewTrials(int trailsNumber);
		OptimizerSolution DoLocalVerification(OptimizerSolution startPoint);

	public:
		OptimizerAlgorithmUnconstrained();
		~OptimizerAlgorithmUnconstrained();

		void SetTask(OptimizerFunctionPtr function,
			OptimizerSpaceTransformation spaceTransform);
		void SetThreadsNum(int num);
		void SetParameters(OptimizerParameters params);

		OptimizerResult StartOptimization(const double* xOpt,
			StopCriterionType stopType);

		double GetLipschitzConst() const;
		OptimizerSearchSequence GetSearchSequence() const;

	};
}
#endif
\end{lstlisting}
\begin{lstlisting}[frame=single]
	#include "OptimizerAlgorithmUnconstrained.hpp"
	#include "HookeJeevesLocalMethod.hpp"

	#include <cassert>
	#include <algorithm>

	using namespace optimizercore;
	using namespace optimizercore::utils;

	OptimizerAlgorithmUnconstrained::OptimizerAlgorithmUnconstrained()
	{
		mIsAlgorithmMemoryAllocated = false;

		mLocalStartIterationNumber = 1;
		mNumberOfThreads = 1;
		mMaxNumberOfIterations = 5000;
		mNextPoints = nullptr;
		mNextTrialsPoints = nullptr;
		mIntervalsForTrials = nullptr;
		r = 2;
		mLocalTuningMode = LocalTuningMode::None;

		mIsTaskInitialized = false;
		mIsParamsInitialized = false;
	}

	void OptimizerAlgorithmUnconstrained::SetTask(OptimizerFunctionPtr function,
		OptimizerSpaceTransformation spaceTransform)
	{
		assert(function);

		mTargetFunctionSmartPtr = function;
		mTargetFunction = function.get();
		mSpaceTransform = spaceTransform;

		mIsTaskInitialized = true;
	}

	OptimizerSearchSequence OptimizerAlgorithmUnconstrained::GetSearchSequence() const
	{
		return OptimizerSearchSequence(mSearchInformationStorage, mMethodDimension,
			static_cast<MapType> (mMapType), mMapTightness, mSpaceTransform);
	}

	double OptimizerAlgorithmUnconstrained::GetLipschitzConst() const
	{
		return mGlobalM;
	}

	void OptimizerAlgorithmUnconstrained::SetParameters(OptimizerParameters params)
	{
		assert(params.algDimention);
		assert(params.eps > 0);
		assert(params.localAlgStartIterationNumber > 0);
		assert(params.mapTightness > 5 && params.mapTightness <= 20);
		assert(params.maxIterationsNumber > 0);
		assert(params.localMixParameter >= 0 && params.localMixParameter <= 20);
		assert(params.r != nullptr);
		assert(params.numberOfThreads > 0);
		assert(params.reserves != nullptr);
		assert(params.numberOfMaps > 0);

		mLocalStartIterationNumber = params.localAlgStartIterationNumber;
		eps = params.eps;
		if (params.localMixParameter <= 10)	{
			mLocalMixParameter = params.localMixParameter;
			mLocalMixType = true;
		}
		else	{
			mLocalMixParameter = 20 - params.localMixParameter;
			mLocalMixType = false;
		}
		mNeedLocalVerification = params.localVerification;
		mAlpha = params.localExponent;
		mMethodDimension = params.algDimention;
		mMapTightness = params.mapTightness;
		mMapType = static_cast<int>(params.mapType);
		mMaxNumberOfIterations = params.maxIterationsNumber;
		mLocalTuningMode = params.localTuningMode;
		r = *params.r;
		if (mNextPoints)
			utils::DeleteMatrix(mNextPoints, mNumberOfThreads);
		mNextPoints = utils::AllocateMatrix<double>(mNumberOfThreads, mMethodDimension);
		this->SetThreadsNum(params.numberOfThreads);

		mIsParamsInitialized = true;
	}

	void OptimizerAlgorithmUnconstrained::InitializeInformationStorage()
	{
		if (!mIsAlgorithmMemoryAllocated){
			AllocMem();
			mIsAlgorithmMemoryAllocated = true;
		}

		mZ = HUGE_VAL;
		mGlobalM = 1;
		mMaxIntervalNorm = 0;

		mSearchInformationStorage.clear();

		mapd(0.0, mMapTightness, mNextPoints[0], mMethodDimension, mMapType);
		mSpaceTransform.Transform(mNextPoints[0], mNextPoints[0]);
		mSearchInformationStorage.emplace(0.0, mTargetFunction->Calculate(mNextPoints[0]), 0);

		mapd(1.0, mMapTightness, mNextPoints[0], mMethodDimension, mMapType);
		mSpaceTransform.Transform(mNextPoints[0], mNextPoints[0]);
		mSearchInformationStorage.emplace(1.0, mTargetFunction->Calculate(mNextPoints[0]), 0);
	}

	bool OptimizerAlgorithmUnconstrained::InsertNewTrials(int trailsNumber)
	{
		bool storageInsertionError;
		if (mMapType == 3)
		{
			int preimagesNumber = 0;
			double preimages[32];
			for (int i = 0; i < trailsNumber; i++)
			{
				invmad(mMapTightness, preimages, 32,
					&preimagesNumber, mNextPoints[i], mMethodDimension, 4);
				for (int k = 0; k < preimagesNumber; k++)
				{
					mNextTrialsPoints[i].x = preimages[k];
					auto insertionResult =
						mSearchInformationStorage.insert(mNextTrialsPoints[i]);

					if (!(storageInsertionError = insertionResult.second))
						break;

					UpdateGlobalM(insertionResult.first);
				}
			}
		}
		else
			for (int i = 0; i < trailsNumber; i++)
			{
				auto insertionResult =
					mSearchInformationStorage.insert(mNextTrialsPoints[i]);

				if (!(storageInsertionError = insertionResult.second))
					break;

				UpdateGlobalM(insertionResult.first);
			}
		return storageInsertionError;
	}

	OptimizerResult OptimizerAlgorithmUnconstrained::StartOptimization(
		const double* a, StopCriterionType stopType)
	{
		assert(mIsParamsInitialized && mIsTaskInitialized);
		assert(mSpaceTransform.GetDomainDimension() == mMethodDimension);

		InitializeInformationStorage();

		double *y;
		bool stop = false;
		int iterationsCount = 0,
			currentThrNum = 1, ranksUpdateErrCode;

		mNextTrialsPoints[0].x = 0.5;
		mapd(mNextTrialsPoints[0].x, mMapTightness, mNextPoints[0],
			mMethodDimension, mMapType);
		mSpaceTransform.Transform(mNextPoints[0], mNextPoints[0]);

		while (iterationsCount < mMaxNumberOfIterations && !stop)	{
			iterationsCount++;

	#pragma omp parallel for num_threads(currentThrNum)
			for (int i = 0; i < currentThrNum; i++)	{
				mNextTrialsPoints[i].val = mTargetFunction->Calculate(mNextPoints[i]);
				if (mMapType == 3)
					mSpaceTransform.InvertTransform(mNextPoints[i], mNextPoints[i]);
	#pragma omp critical
				if (mNextTrialsPoints[i].val < mZ)
					mZ = mNextTrialsPoints[i].val;
			}

			if (!InsertNewTrials(currentThrNum))
				break;

			if (iterationsCount >= mLocalStartIterationNumber)	{
				if (iterationsCount % (12 - mLocalMixParameter) == 0
					&& mLocalMixParameter > 0)
					ranksUpdateErrCode = UpdateRanks(mLocalMixType);
				else
					ranksUpdateErrCode = UpdateRanks(!mLocalMixType);
			}
			else
				ranksUpdateErrCode = UpdateRanks(false);

			if (iterationsCount >= mNumberOfThreads + 10)
				currentThrNum = mNumberOfThreads;

			for (int i = 0; i < currentThrNum && !stop; i++)	{
				OptimizerTrialPoint left = mIntervalsForTrials[i].left;
				OptimizerTrialPoint right = mIntervalsForTrials[i].right;

				mNextTrialsPoints[i].x = (left.x + right.x) / 2
					- sgn(right.val - left.val)*pow(fabs(right.val - left.val)
					/ mIntervalsForTrials[i].localM, mMethodDimension) / (2 * r);

				mapd(mNextTrialsPoints[i].x, mMapTightness, mNextPoints[i],
					mMethodDimension, mMapType);
				mSpaceTransform.Transform(mNextPoints[i], mNextPoints[i]);

				y = mNextPoints[i];

				if (stopType == StopCriterionType::OptimalPoint)	{
					if (NormNDimMax(y, a, mMethodDimension) < eps)	{
						stop = true;
						mOptimumEvaluation = mNextTrialsPoints[i];
					}
				}
				else	{
					if (pow(right.x - left.x, 1.0 / mMethodDimension) < eps)	{
						stop = true;
						mOptimumEvaluation = mNextTrialsPoints[i];
					}
				}
			}
		}

		mOptimumEvaluation.val = mTargetFunction->Calculate(y);
		mSearchInformationStorage.insert(mOptimumEvaluation);

		if (stopType == StopCriterionType::Precision)
			mOptimumEvaluation = *std::min_element(mSearchInformationStorage.begin(),
				mSearchInformationStorage.cend(),
				[](OptimizerTrialPoint p1, OptimizerTrialPoint p2)
			{
				return p1.val < p2.val;
			});

		mapd(mOptimumEvaluation.x, mMapTightness, y, mMethodDimension, mMapType);
		mSpaceTransform.Transform(y, y);

		SharedVector optPoint(new double[mMethodDimension], array_deleter<double>());
		std::memcpy(optPoint.get(), y, mMethodDimension*sizeof(double));

		OptimizerSolution solution(iterationsCount, mOptimumEvaluation.val,
			mOptimumEvaluation.x, mMethodDimension, optPoint);

		if (mNeedLocalVerification)
			return OptimizerResult(DoLocalVerification(solution));
		else
			return OptimizerResult(solution);
	}
	OptimizerSolution OptimizerAlgorithmUnconstrained::DoLocalVerification(OptimizerSolution startSolution)
	{
		OptimizerFunctionPtr *functions = new OptimizerFunctionPtr[1];
		functions[0] = mTargetFunctionSmartPtr;

		OptimizerTask localTask(std::shared_ptr<OptimizerFunctionPtr>(functions,
			utils::array_deleter<OptimizerFunctionPtr>()),
			0, mMethodDimension, mSpaceTransform.GetLeftDomainBound(),
			mSpaceTransform.GetRightDomainBound());

		localoptimizer::HookeJeevesLocalMethod localMethod;
		localMethod.SetEps(eps / 100);
		localMethod.SetInitialStep(2 * eps);
		localMethod.SetProblem(localTask);
		localMethod.SetStepMultiplier(2);
		localMethod.SetStartPoint(startSolution.GetOptimumPoint().get(),
			localTask.GetTaskDimension());

		SharedVector localOptimum(new double[mMethodDimension], array_deleter<double>());
		localMethod.StartOptimization(localOptimum.get());
		double bestLocalValue = mTargetFunction->Calculate(localOptimum.get());

		if (startSolution.GetOptimumValue() > bestLocalValue)
			return OptimizerSolution(startSolution.GetIterationsCount(),
			bestLocalValue, 0.5, mMethodDimension, localOptimum);

		return startSolution;
	}
	void OptimizerAlgorithmUnconstrained::SetThreadsNum(int num)
	{
		if (num > 0 && num < 100)
		{
			if (mNextPoints != nullptr)
				utils::DeleteMatrix(mNextPoints, mNumberOfThreads);
			mNumberOfThreads = num;
			if (mNextTrialsPoints)
				delete[] mNextTrialsPoints;
			if (mIntervalsForTrials)
				delete[] mIntervalsForTrials;
			mIntervalsForTrials = new OptimizerInterval[num];
			mNextTrialsPoints = new OptimizerTrialPoint[num];
			mNextPoints = utils::AllocateMatrix<double>(
				mNumberOfThreads, mMethodDimension);
		}
	}
	OptimizerAlgorithmUnconstrained::~OptimizerAlgorithmUnconstrained()
	{
		if (mIntervalsForTrials)
			delete[] mIntervalsForTrials;
		if (mNextPoints)
			utils::DeleteMatrix(mNextPoints, mNumberOfThreads);
		if (mNextTrialsPoints)
			delete[] mNextTrialsPoints;
		if (mIsAlgorithmMemoryAllocated)
		{
		}
	}
	void OptimizerAlgorithmUnconstrained::UpdateGlobalM(
		std::set<OptimizerTrialPoint>::iterator& newPointIt)
	{
		double max = mGlobalM;
		if (max == 1) max = 0;


		auto leftPointIt = newPointIt;
		auto rightPointIt = newPointIt;
		--leftPointIt;
		++rightPointIt;

		double leftIntervalNorm = pow(newPointIt->x - leftPointIt->x, 1.0 / mMethodDimension);
		double rightIntervalNorm = pow(rightPointIt->x - newPointIt->x, 1.0 / mMethodDimension);


		max = fmax(fmax(fabs(newPointIt->val - leftPointIt->val) / leftIntervalNorm,
			fabs(rightPointIt->val - newPointIt->val) /	rightIntervalNorm), max);


		mMaxIntervalNorm = 0;
		auto currentPointIt = mSearchInformationStorage.begin();
		auto nextPointIt = currentPointIt;
		++nextPointIt;

		while (nextPointIt != mSearchInformationStorage.cend())
		{
			if (mLocalTuningMode != LocalTuningMode::None)
				mMaxIntervalNorm = fmax(
					pow(nextPointIt->x - currentPointIt->x, 1.0 / mMethodDimension),
					mMaxIntervalNorm);

			++currentPointIt;
			++nextPointIt;
		}
		if (max != 0)
			mGlobalM = max;
		else
			mGlobalM = 1;
	}
	int OptimizerAlgorithmUnconstrained::UpdateRanks(bool isLocal)
	{
		double dx, curr_rank, mu1 = -HUGE_VAL, localM = mGlobalM;
		double localMConsts[3];

		for (int i = 0; i < mNumberOfThreads; i++)
			mIntervalsForTrials[i].R = -HUGE_VAL;

		auto leftIt = mSearchInformationStorage.begin();
		auto rightIt = mSearchInformationStorage.begin();
		++rightIt;

		int storageSize = mSearchInformationStorage.size();

		for (int j = 0; j < storageSize - 1; j++)
		{
			dx = pow(rightIt->x - leftIt->x, 1.0 / mMethodDimension);

			if (dx == 0)
				return 1;

			if (mLocalTuningMode != LocalTuningMode::None)	{
				std::set<OptimizerTrialPoint>::iterator rightRightIt = rightIt;

				if (j > 0 && j < storageSize - 2)	{
					++rightRightIt;

					std::swap(localMConsts[0], localMConsts[1]);
					std::swap(localMConsts[1], localMConsts[2]);

					localMConsts[2] = fabs(rightRightIt->val - rightIt->val)
						/ pow(rightRightIt->x - rightIt->x, 1.0 / mMethodDimension);

					mu1 = fmax(fmax(localMConsts[0], localMConsts[1]), localMConsts[2]);
				}
				else if (j == 0)	{
					++rightRightIt;

					localMConsts[1] = fabs(rightIt->val - leftIt->val) / dx;
					localMConsts[2] = fabs(rightRightIt->val - rightIt->val) /
						pow(rightRightIt->x - rightIt->x, 1.0 / mMethodDimension);
					mu1 = fmax(localMConsts[1], localMConsts[2]);
				}
				else
					mu1 = fmax(localMConsts[1], localMConsts[2]);

				double mu2 = mGlobalM*dx / mMaxIntervalNorm;

				if (mLocalTuningMode == LocalTuningMode::Maximum)	{
					localM = fmax(fmax(mu1, mu2), 0.01);
				}
				else// LocalTuningMode::Adaptive
					localM = fmax(mu1 / r + (1 - 1 / r)*mGlobalM, 0.01);
					//localM = fmax(mu1*(1 - dx / mMaxIntervalNorm) + mu2, 0.01);
				  //localM = fmax(mu1*mMConvolution + (1 - mMConvolution)*mu2, 0.01);
			}

			curr_rank = dx + Pow2((rightIt->val - leftIt->val) / (r * localM)) / dx
				- 2 * (rightIt->val + leftIt->val - 2 * mZ) / (r * localM);
			if (isLocal)
				curr_rank /= sqrt((rightIt->val - mZ)*
				(leftIt->val - mZ)) / localM + pow(1.5, -mAlpha);

			if (curr_rank > mIntervalsForTrials[mNumberOfThreads - 1].R)
			{
				OptimizerInterval newInterval(
					OptimizerTrialPoint(*leftIt),
					OptimizerTrialPoint(*rightIt), curr_rank, localM);
				for (int i = 0; i < mNumberOfThreads; i++)
					if (mIntervalsForTrials[i].R < newInterval.R)
						std::swap(mIntervalsForTrials[i], newInterval);
			}
			++leftIt;
			++rightIt;
		}
		return 0;
	}
	void OptimizerAlgorithmUnconstrained::AllocMem()
	{
	}
\end{lstlisting}

\subsection{Приложение 2}
\label{attach2}
\begin{lstlisting}[frame=single]
#ifndef __OPTMAL_CONTROL_PROBLEM_H__
#define __OPTMAL_CONTROL_PROBLEM_H__

#include "problem_interface.h"

#include <Eigen/Dense>

class TOptimalControlProblem : public IProblem
{
protected:
  int mDimension;
  bool mIsInitialized;
  static const int mMaxDimension = 4;

  int n_x;
  int n_v;
  int n_u;
  std::vector<int> n_k;

  Eigen::MatrixXd A;
  Eigen::MatrixXd B_u;
  Eigen::MatrixXd B_v;
  Eigen::MatrixXd YVec;
  std::vector<Eigen::MatrixXd> CMatrices;
  std::vector<Eigen::MatrixXd> DMatrices;

public:
  TOptimalControlProblem();
  virtual int SetConfigPath(const std::string& configPath);
  virtual int SetDimension(int dimension);
  virtual int GetDimension() const;
  virtual int Initialize();

  virtual void GetBounds(double* lower, double *upper);
  virtual int GetOptimumValue(double& value) const;
  virtual int GetOptimumPoint(double* x) const;

  virtual int GetNumberOfFunctions() const;
  virtual int GetNumberOfConstraints() const;
  virtual int GetNumberOfCriterions() const;

  virtual double CalculateFunctionals(const double* x, int fNumber);

  ~TOptimalControlProblem();
};

extern "C" LIB_EXPORT_API IProblem* create();
extern "C" LIB_EXPORT_API void destroy(IProblem* ptr);

#endif
\end{lstlisting}
\begin{lstlisting}[frame=single]
#include "optimalControl.h"

#define _USE_MATH_DEFINES
#include <math.h>

#include <unsupported/Eigen/KroneckerProduct>
#include <stdexcept>
#include <algorithm>

using namespace Eigen;

TOptimalControlProblem::TOptimalControlProblem()
{
	mIsInitialized = false;

  //oscillation damping

  double beta = 0.1;
  n_x = 4;
  n_v = 1;
  n_u = 1;
  n_k.resize(2);
  n_k[0] = n_k[1] = 1;

  CMatrices.resize(2);
  DMatrices.resize(2);

  A.resize(4, 4);
  A << 0, 0, 1, 0,
    0, 0, 0, 1,
    -2, 1, -2*beta, beta,
    1, -1, beta, -beta;

  B_u.resize(4, 1); B_u << 0, 0, 0, 1;
  B_v.resize(4, 1); B_v << 0, 0, 1, 1;

  CMatrices[0].resize(2, 4);
  CMatrices[0] << 1, 0, 0, 0,
    -1, 1, 0, 0;
  CMatrices[1].resize(1, 4); CMatrices[1] << 0, 0, 0, 0;

  DMatrices[0].resize(2, 1); DMatrices[0] << 0, 0;
  DMatrices[1].resize(1, 1); DMatrices[1] << 1;


	mDimension = n_x;
}

int TOptimalControlProblem::SetConfigPath(const std::string& configPath)
{
	return IProblem::OK;
}

int TOptimalControlProblem::SetDimension(int dimension)
{
	if(dimension >= mMaxDimension && dimension <= mMaxDimension)
	{
		mDimension = dimension;
		return IProblem::OK;
	}
	else
		return IProblem::ERROR;
}

int TOptimalControlProblem::GetDimension() const
{
	return mDimension;
}

int TOptimalControlProblem::Initialize()
{
	if (mDimension > 0)
	{
		mIsInitialized = true;
		return IProblem::OK;
	}
	else
		return IProblem::ERROR;
}

void TOptimalControlProblem::GetBounds(double* lower, double *upper)
{
	if (mIsInitialized)
		for (int i = 0; i < mDimension; i++)
		{
      if(mDimension == 2)
			  upper[i] = -0.2;
      else
        upper[i] = 1.;
      lower[i] = -2.0;
		}
}

int TOptimalControlProblem::GetOptimumValue(double& value) const
{
	return IProblem::UNDEFINED;
}

int TOptimalControlProblem::GetOptimumPoint(double* point) const
{
	return IProblem::UNDEFINED;
}

int TOptimalControlProblem::GetNumberOfFunctions() const
{
	return 3;
}

int TOptimalControlProblem::GetNumberOfConstraints() const
{
	return 2;
}

int TOptimalControlProblem::GetNumberOfCriterions() const
{
	return 1;
}

double TOptimalControlProblem::CalculateFunctionals(const double* x, int fNumber)
{
  Map<const RowVectorXd> theta(x, mDimension);

  if (fNumber == 0 || mDimension == 2) // for compatibility with plotter
  {
    MatrixXd Atheta = A + B_u*theta;

    EigenSolver<MatrixXd> eigenSolver(Atheta, false);
    MatrixXcd eigenvalues = eigenSolver.eigenvalues();
    double maxReal = -HUGE_VAL;
    for (int i = 0; i < Atheta.cols(); i++)
      maxReal = std::max(maxReal, eigenvalues.coeff(i).real());

    MatrixXd E = MatrixXd::Identity(mDimension, mDimension);
    MatrixXd S = kroneckerProduct(E, Atheta) + kroneckerProduct(Atheta, E);

    MatrixXd rhs = -B_v*B_v.transpose();
    Map<VectorXd> rhsMap(rhs.data(), rhs.size());
    YVec = S.householderQr().solve(rhsMap);

    if (fNumber == 0)
      return maxReal + 0.02;
  }
  Map<MatrixXd> Y(YVec.data(), A.cols(), A.rows());

  double value = -HUGE_VAL;
  fNumber--;
  double offset = fNumber == 0 ? -1. : 0.;

  int cRows = CMatrices[fNumber].rows();
  for (int i = 0; i < cRows; i++)
  {
    RowVectorXd currentVector = CMatrices[fNumber].row(i) + DMatrices[fNumber].row(i)*theta;
    double dotProd = (currentVector*Y).dot(currentVector.transpose());
    value = std::max(value, dotProd);
  }
  return sqrt(value) + offset;
}

TOptimalControlProblem::~TOptimalControlProblem()
{

}

LIB_EXPORT_API IProblem* create()
{
	return new TOptimalControlProblem();
}

LIB_EXPORT_API void destroy(IProblem* ptr)
{
	delete ptr;
}
\end{lstlisting}
